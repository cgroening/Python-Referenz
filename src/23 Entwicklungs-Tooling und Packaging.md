# Entwicklungs-Tooling & Packaging

Modernes Python-Dependency-Management und Packaging haben sich in den letzten Jahren stark weiterentwickelt. Dieses Kapitel behandelt Virtual Environments, Dependency-Management-Tools und moderne Packaging-Standards.

## 1    Virtual Environments

Virtual Environments isolieren Python-Projekte voneinander und vermeiden Versionskonflikte zwischen Abhängigkeiten.

### 1.1    `venv` – Standard Virtual Environment

```bash
# Virtual Environment erstellen
python -m venv myenv

# Aktivieren (Linux/macOS)
source myenv/bin/activate

# Aktivieren (Windows)
myenv\Scripts\activate

# Deaktivieren
deactivate

# Löschen (einfach Ordner entfernen)
rm -rf myenv
```

**Wichtige Punkte:**

- `venv` ist seit Python 3.3 Teil der Standardbibliothek
- Erstellt isolierte Python-Installation mit eigenem `site-packages`
- Sollte **nicht** ins Git-Repository committed werden

### 1.2    Wo liegt was?

```bash
myenv/
├── bin/           # Aktivierungsscripts und Python-Interpreter (Linux/macOS)
├── Scripts/       # Aktivierungsscripts und Python-Interpreter (Windows)
├── include/       # C-Header-Dateien für Extensions
├── lib/
│   └── python3.x/
│       └── site-packages/  # Installierte Pakete
└── pyvenv.cfg     # Konfiguration des Virtual Environment
```

### 1.3    `virtualenv` – Alternative zu venv

```bash
# Installation
pip install virtualenv

# Virtual Environment erstellen
virtualenv myenv

# Mit spezifischer Python-Version
virtualenv -p python3.11 myenv

# Vorteile gegenüber venv:
# - Schnellere Erstellung
# - Mehr Konfigurationsoptionen
# - Kompatibel mit älteren Python-Versionen
```

### 1.4    `.gitignore` für Virtual Environments

```gitignore
# Virtual Environments
venv/
env/
ENV/
myenv/
.venv/

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
```

## 2    Klassisches Dependency Management mit `pip`

### 2.1    Pakete installieren

```bash
# Einzelnes Paket
pip install requests

# Spezifische Version
pip install requests==2.31.0

# Mindestversion
pip install requests>=2.30.0

# Versionsbereiche
pip install "requests>=2.30.0,<3.0.0"

# Aus requirements.txt
pip install -r requirements.txt

# Paket aktualisieren
pip install --upgrade requests

# Paket deinstallieren
pip uninstall requests
```

### 2.2    `requirements.txt`

```txt
# requirements.txt - Produktions-Dependencies
requests==2.31.0
pandas>=2.0.0,<3.0.0
numpy==1.24.3
python-dotenv==1.0.0

# Optional: Kommentare
matplotlib==3.7.1  # Für Visualisierungen
```

```bash
# Requirements generieren (nicht empfohlen für Entwicklung)
pip freeze > requirements.txt

# Installieren
pip install -r requirements.txt
```

### 2.3    Mehrere Requirements-Dateien

```bash
# Projektstruktur
requirements/
├── base.txt          # Basis-Dependencies
├── dev.txt           # Entwicklungs-Tools
└── production.txt    # Produktions-spezifisch
```

```txt
# requirements/base.txt
requests==2.31.0
pandas==2.0.3

# requirements/dev.txt
-r base.txt  # Basis-Dependencies inkludieren
pytest==7.4.0
black==23.7.0
mypy==1.5.0

# requirements/production.txt
-r base.txt
gunicorn==21.2.0
```

```bash
# Entwicklungsumgebung
pip install -r requirements/dev.txt

# Produktion
pip install -r requirements/production.txt
```

### 2.4    Probleme mit `pip freeze`

```bash
# ❌ Problematisch: pip freeze
pip freeze > requirements.txt
```

**Nachteile:**

- Listet **alle** installierten Pakete auf (auch transitive Dependencies)
- Keine Trennung zwischen direkten und indirekten Abhängigkeiten
- Versionsnummern sind exakt → keine Flexibilität bei Updates
- Schwer wartbar bei vielen Paketen

## 3    `pip-tools` – Besseres Dependency Management

`pip-tools` löst viele Probleme von `pip freeze` durch Trennung von abstrakten und konkreten Dependencies.

### 3.1    Installation

```bash
pip install pip-tools
```

### 3.2    Workflow mit `pip-compile`

```txt
# requirements.in - Was wir WOLLEN (abstrakt)
requests>=2.30.0
pandas
pytest>=7.0
```

```bash
# Konkrete Versionen generieren
pip-compile requirements.in

# Erzeugt requirements.txt mit allen transitiven Dependencies
```

```txt
# requirements.txt - Was INSTALLIERT wird (konkret)
# Generated by pip-compile
requests==2.31.0
  # via -r requirements.in
certifi==2023.7.22
  # via requests
charset-normalizer==3.2.0
  # via requests
idna==3.4
  # via requests
urllib3==2.0.4
  # via requests
pandas==2.0.3
  # via -r requirements.in
numpy==1.24.3
  # via pandas
...
```

### 3.3    `pip-sync` – Exakte Environment-Replikation

```bash
# Virtual Environment exakt auf requirements.txt synchronisieren
pip-sync requirements.txt

# Entfernt Pakete, die nicht in requirements.txt sind
# Installiert fehlende Pakete
# Aktualisiert auf exakte Versionen
```

### 3.4    Dependency-Updates

```bash
# Alle Dependencies aktualisieren
pip-compile --upgrade requirements.in

# Nur ein spezifisches Paket aktualisieren
pip-compile --upgrade-package requests requirements.in

# Mit Hashes für zusätzliche Sicherheit
pip-compile --generate-hashes requirements.in
```

### 3.5    Mehrere Environments mit pip-tools

```txt
# requirements.in
requests
pandas

# requirements-dev.in
-c requirements.txt  # Constraint-File: nutze dieselben Versionen
pytest
black
mypy
```

```bash
# Workflow
pip-compile requirements.in
pip-compile requirements-dev.in

# Installation
pip-sync requirements-dev.txt  # Installiert dev + base
```

## 4    Poetry – All-in-One Lösung

Poetry kombiniert Dependency Management, Packaging und Veröffentlichung in einem Tool.

### 4.1    Installation

```bash
# Empfohlene Installation (Linux/macOS)
curl -sSL https://install.python-poetry.org | python3 -

# Alternative: pipx (isoliert)
pipx install poetry

# Nach Installation
poetry --version
```

### 4.2    Neues Projekt initialisieren

```bash
# Interaktive Projekt-Erstellung
poetry new myproject

# Generierte Struktur:
myproject/
├── pyproject.toml
├── README.md
├── myproject/
│   └── __init__.py
└── tests/
    └── __init__.py
```

```bash
# In bestehendem Projekt
poetry init
```

### 4.3    `pyproject.toml` – Poetry-Konfiguration

```toml
[tool.poetry]
name = "myproject"
version = "0.1.0"
description = "A sample Python project"
authors = ["Your Name <you@example.com>"]
readme = "README.md"
license = "MIT"

[tool.poetry.dependencies]
python = "^3.10"
requests = "^2.31.0"
pandas = "^2.0.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
black = "^23.7.0"
mypy = "^1.5.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

### 4.4    Dependencies verwalten

```bash
# Paket hinzufügen
poetry add requests

# Dev-Dependency hinzufügen
poetry add --group dev pytest

# Mit Version Constraints
poetry add "requests>=2.30.0,<3.0.0"

# Paket entfernen
poetry remove requests

# Alle Dependencies installieren
poetry install

# Ohne dev-dependencies (Produktion)
poetry install --without dev

# Dependencies aktualisieren
poetry update

# Nur ein Paket aktualisieren
poetry update requests
```

### 4.5    Virtual Environment mit Poetry

```bash
# Poetry erstellt automatisch ein Virtual Environment
poetry install

# In der Poetry-Shell arbeiten
poetry shell

# Befehl im Poetry-Environment ausführen (ohne shell)
poetry run python script.py
poetry run pytest

# Environment-Info anzeigen
poetry env info

# Environment-Pfad
poetry env info --path

# Environment löschen
poetry env remove python3.10
```

### 4.6    Lock-File

Poetry erstellt automatisch `poetry.lock`:

```bash
# poetry.lock - Exakte Versionen aller Dependencies
# Wird automatisch bei 'poetry add' / 'poetry update' aktualisiert
# SOLLTE ins Git committed werden

# Lock-File neu generieren ohne Installation
poetry lock

# Lock-File prüfen
poetry check
```

### 4.7    Scripts definieren

```toml
[tool.poetry.scripts]
start = "myproject.main:main"
test = "pytest"
```

```bash
# Scripts ausführen
poetry run start
poetry run test
```

### 4.8    Packaging und Veröffentlichung

```bash
# Paket bauen
poetry build
# Erstellt dist/myproject-0.1.0.tar.gz und .whl

# Auf PyPI veröffentlichen
poetry publish

# Beides zusammen
poetry publish --build

# Test-PyPI
poetry config repositories.testpypi https://test.pypi.org/legacy/
poetry publish -r testpypi
```

## 5    `pyproject.toml` – PEP 621 Standard

`pyproject.toml` ist der moderne Standard für Python-Projektkonfiguration (definiert in PEP 621).

### 5.1    Grundstruktur ohne Poetry

```toml
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "mypackage"
version = "0.1.0"
description = "A sample Python package"
readme = "README.md"
authors = [
    {name = "Your Name", email = "you@example.com"}
]
license = {text = "MIT"}
requires-python = ">=3.10"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
]
keywords = ["example", "package"]

dependencies = [
    "requests>=2.30.0",
    "pandas>=2.0.0,<3.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
    "black>=23.7.0",
    "mypy>=1.5.0",
]
docs = [
    "sphinx>=7.0.0",
]

[project.urls]
Homepage = "https://github.com/username/mypackage"
Documentation = "https://mypackage.readthedocs.io"
Repository = "https://github.com/username/mypackage"
```

### 5.2    Installation mit pip

```bash
# Paket installieren (im Entwicklungsmodus)
pip install -e .

# Mit optional dependencies
pip install -e ".[dev]"
pip install -e ".[dev,docs]"
```

### 5.3    Dynamische Versionen

```toml
[project]
name = "mypackage"
dynamic = ["version"]  # Version aus Code lesen

[tool.setuptools.dynamic]
version = {attr = "mypackage.__version__"}
```

```python
# mypackage/__init__.py
__version__ = "0.1.0"
```

### 5.4    Entry Points / Console Scripts

```toml
[project.scripts]
myapp = "mypackage.cli:main"
mytool = "mypackage.tools:run"
```

```python
# mypackage/cli.py
def main():
    print("Hello from myapp!")

if __name__ == "__main__":
    main()
```

```bash
# Nach Installation verfügbar:
myapp  # Ruft mypackage.cli:main() auf
```

## 6    Verschiedene Build-Backends

### 6.1    setuptools (Standard)

```toml
[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"
```

### 6.2    Poetry

```toml
[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"
```

### 6.3    Flit (minimalistisch)

```toml
[build-system]
requires = ["flit_core>=3.2"]
build-backend = "flit_core.buildapi"

[project]
name = "mypackage"
authors = [{name = "Your Name"}]
dynamic = ["version", "description"]
```

### 6.4    Hatch (modern)

```toml
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

## 7    Tool-Konfiguration in `pyproject.toml`

### 7.1    Black (Formatter)

```toml
[tool.black]
line-length = 88
target-version = ['py310', 'py311']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.venv
  | build
  | dist
)/
'''
```

### 7.2    MyPy (Type Checker)

```toml
[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true

[[tool.mypy.overrides]]
module = "pandas.*"
ignore_missing_imports = true
```

### 7.3    Pytest

```toml
[tool.pytest.ini_options]
minversion = "7.0"
addopts = "-ra -q --strict-markers"
testpaths = [
    "tests",
]
markers = [
    "slow: marks tests as slow",
    "integration: integration tests",
]
```

### 7.4    Ruff (Linter & Formatter)

```toml
[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
select = ["E", "F", "I", "N", "W"]
ignore = ["E501"]

[tool.ruff.lint.per-file-ignores]
"__init__.py" = ["F401"]
```

## 8    Vergleich der Tools

### 8.1    Feature-Matrix

| Feature                  | pip + venv | pip-tools | Poetry | Hatch |
| ------------------------ | ---------- | --------- | ------ | ----- |
| Dependency Resolution    | ✅ Basis   | ✅ Gut    | ✅ Sehr gut | ✅ Sehr gut |
| Lock-Files               | ❌         | ✅        | ✅     | ✅    |
| Virtual Env Management   | ⚠️ Manuell | ⚠️ Manuell | ✅ Automatisch | ✅ Automatisch |
| Packaging                | ⚠️ Separat | ⚠️ Separat | ✅ Integriert | ✅ Integriert |
| Publishing               | ⚠️ Separat | ⚠️ Separat | ✅ Integriert | ✅ Integriert |
| pyproject.toml           | ✅         | ✅        | ✅     | ✅    |
| Lernkurve                | ✅ Niedrig | ✅ Niedrig | ⚠️ Mittel | ⚠️ Mittel |
| Performance              | ✅         | ✅        | ⚠️ Langsamer | ✅ |
| Ökosystem-Integration    | ✅ Maximal | ✅ Gut    | ⚠️ Eigenes Ökosystem | ✅ Gut |

### 8.2    Wann was verwenden?

**pip + venv:**

- Einfache Projekte ohne komplexe Dependencies
- CI/CD-Pipelines (minimale Abhängigkeiten)
- Lern-/Tutorial-Projekte
- Schnelle Prototypen

**pip-tools:**

- Mittlere bis große Projekte
- Wenn exakte Reproduzierbarkeit wichtig ist
- Wenn man bei pip-Ökosystem bleiben will
- CI/CD mit deterministischen Builds

**Poetry:**

- Neue Projekte von Grund auf
- Library-Entwicklung mit Veröffentlichung
- Wenn All-in-One-Lösung gewünscht
- Team-Projekte mit standardisiertem Workflow
- Wenn Virtual Env automatisch verwaltet werden soll

**Hatch:**

- Moderne Alternative zu Poetry
- Schnellere Builds
- Mehrere Python-Versionen testen
- Wenn man mehr Kontrolle als Poetry will

## 9    Best Practices

### 9.1    Allgemeine Empfehlungen

```bash
# ✅ DO: Virtual Environments nutzen
python -m venv venv
source venv/bin/activate

# ✅ DO: pyproject.toml statt setup.py
# Modern und standardisiert

# ✅ DO: Lock-Files ins Git committen
# poetry.lock, requirements.txt (von pip-compile)

# ❌ DON'T: Virtual Environment committen
# Gehört in .gitignore

# ❌ DON'T: pip freeze für Dependency-Management
# Nutze pip-tools oder Poetry

# ✅ DO: Versions-Constraints spezifizieren
requests = "^2.31.0"  # Poetry
requests>=2.31.0,<3.0.0  # pip
```

### 9.2    Entwicklungs-Workflow (Poetry)

```bash
# 1. Projekt initialisieren
poetry new myproject
cd myproject

# 2. Dependencies hinzufügen
poetry add requests pandas
poetry add --group dev pytest black mypy

# 3. Installation
poetry install

# 4. Entwicklung
poetry shell
# oder
poetry run python main.py
poetry run pytest

# 5. Code formatieren/testen
poetry run black .
poetry run mypy .
poetry run pytest

# 6. Vor Commit: Lock-File aktualisieren falls nötig
poetry lock --no-update

# 7. Packaging
poetry build
poetry publish
```

### 9.3    CI/CD Integration

**GitHub Actions mit Poetry:**

```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 1.6.0
      
      - name: Install dependencies
        run: poetry install
      
      - name: Run tests
        run: poetry run pytest
```

**Mit pip-tools:**

```yaml
- name: Install dependencies
  run: |
    pip install pip-tools
    pip-sync requirements.txt
    
- name: Run tests
  run: pytest
```

## 10    Migration zwischen Tools

### 10.1    Von requirements.txt zu Poetry

```bash
# 1. Poetry initialisieren
poetry init

# 2. Dependencies aus requirements.txt importieren
# (manuell in pyproject.toml übertragen)

# 3. Oder mit poetry add
cat requirements.txt | grep -v "#" | xargs poetry add

# 4. Lock-File generieren
poetry lock
```

### 10.2    Von Poetry zu pip-tools

```bash
# 1. Aus pyproject.toml extrahieren
poetry export -f requirements.txt --output requirements.txt

# 2. requirements.in erstellen (manuell vereinfachen)
# Nur direkte Dependencies ohne Versionen/Hashes

# 3. Neu kompilieren
pip-compile requirements.in
```

## 11    Zusammenfassung

| Tool       | Zweck                              | Empfohlen für                        |
| ---------- | ---------------------------------- | ------------------------------------ |
| `venv`     | Virtual Environments               | Alle Projekte                        |
| `pip`      | Paket-Installation                 | Basis-Tool                           |
| `pip-tools`| Dependency-Pinning                 | Deterministische Builds              |
| Poetry     | All-in-One Management              | Neue Projekte, Libraries             |
| Hatch      | Alternative zu Poetry              | Moderne Projekte, Multi-Python       |
| `pyproject.toml` | Standard-Konfiguration       | Alle modernen Projekte               |

**Moderne Empfehlung:**

- **Einfache Projekte**: `venv` + `pip` + `pyproject.toml`
- **Professionelle Projekte**: `pip-tools` oder Poetry
- **Library-Entwicklung**: Poetry oder Hatch
- **Legacy-Migration**: Schrittweise zu `pyproject.toml` wechseln

**Kernprinzip:** Nutze Lock-Files für reproduzierbare Builds, trenne abstrakte von konkreten Dependencies, und setze auf standardisiertes `pyproject.toml` statt proprietärer Konfigurationen.
